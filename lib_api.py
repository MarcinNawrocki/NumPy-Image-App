import json
import math

import numpy as np
import matplotlib.pyplot as plt
from skimage import filters

import basic_operations as bs 
import binary_operations as bn 
import noising as ns 
import filtering as fil 

#filters
#dolnoprzepustowe
np_LP = np.array([[1,1,1],[1,1,1], [1,1,1]])
np_LP1 = np.array([[1,1,1],[1,2,1], [1,1,1]])
np_LP2 = np.array([[1,1,1],[1,4,1], [1,1,1]])
np_LP3 = np.array([[1,1,1],[1,12,1], [1,1,1]])

#gÃ³rnoprzepustowe
np_HP = np.array([[-1,-1,-1],[-1,9,-1], [-1,-1,-1]])
np_HP1 = np.array([[0,-1,0],[-1,5,-1], [0,-1,0]])
np_HP2 = np.array([[1,-2,1],[-2,5,-2], [1,-2,1]])
np_HP2 = np.array([[0,-1,0],[-1,20,-1], [0,-1,0]])

#add more from
#http://www.algorytm.org/przetwarzanie-obrazow/filtrowanie-obrazow.html

#TODO:
#- number_of_inters and size validation
#- eliminate code repeating in:
    #morphological operations
    #filterings(median, filter, gamma)
#- displaying images in rows 
#- other TODO marks in code
#- docstrings in new file

#TESTED
def toGrayscale(np_org_image, gray="human"):
    """Convert image to  grayscale 
    Keyword argument:
    filename --  filename or path to image
    gray:
        human - convert to "human" grayscale (0,215*R+0.7151*G+0.0721*B)
        machine - convert to "machine" grayscale (R+G+B)/3
    Return:
    np_image_gray -- image as grayscale
    """
    
    if bs.isColorImage(np_org_image):
        if gray == "human":
            np_final = bs.getHumanGrayscale(np_org_image)

        elif gray == "machine":
            np_final = bs.getMachineGrayscale(np_org_image)
        else: #default -- np_org_image
            np_final = bs.getHumanGrayscale(np_org_image)
    else:
        np_final = np_org_image

    return np_final

#TESTED
def getBinaryzedImage(np_org_image, threshold, number_of_inters=2): 
    """Return binaryzed image based on threshold given by user
    Keyword argument:
    filename --  filename or path to image
    thershold -- integer value in range (0,255)
    Return:
        Binaryzed image as numpy array with 0 and 255 values
    """

    #TODO threshold out of range 
    if threshold > 255 or threshold < 0:
        return 0

    processed_inters = 0
    images = []
    images.append(np_org_image)

    np_image_2D, isConverted = bs.ensureGrayscale(np_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1
    np_final = bn.thresholdBinaryzation(np_image_2D, threshold)
    #number_of_inters = 0 indicates that function was called by other api function
    if(number_of_inters > 0):
        images += bs.generateInterImages(images[-1], np_final,
                                         number_of_inters, processed_inters)
    else:
        images.append(np_final)

    return images   

#TODO bn.Otsu should return threshold, this function should call getBinaryzed with threshold
#TESTED
def getOtsuBinaryzedImage(np_org_image, number_of_inters=2):
    """Return binaryzed image, by threshold which is generated by OTSU method.
    Algorithm calculated Otsu using maximalization between class variance.
    Keyword argument:
    filename --  filename or path to image
    Return:
        Binaryzed image as numpy array with two values (0 and 255 values).
    """

    processed_inters = 0
    images = []
    images.append(np_org_image)

    np_image_2D, isConverted = bs.ensureGrayscale(np_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    np_final = bn.otsuBinaryzation(np_image_2D)
    
    #number_of_inters = 0 indicates that function was called by other api function
    if(number_of_inters > 0):
        images += bs.generateInterImages(images[-1], np_final,
                                         number_of_inters, processed_inters)
    else:
        images.append(np_final)

    return images

#TESTED
def getDilate(np_org_image, number_of_inters=2, struct_elem='rect', size=3): 
    """Execute dilate morphological operation on image
    Function binaryzed image by OTSU method, so pass RGB or grayscale images possible.
    Keyword argument:
    filename --  filename or path to image
    struct_elem:
        cross - cross structural element
        rect - rectangle structural element
    size: size of struct element, should be 2N+1
    Return:
        Binarized image after dilatation operation
    """

    processed_inters = 0
    images = []
    #original image will be appended in Otsu binaryzation 

    bin_images= getOtsuBinaryzedImage(np_org_image,0)
    processed_inters += len(bin_images) - 1             #minus original image
    images += bin_images

    np_final = bn.dilate(images[-1], struct_elem, size)

    images += bs.generateInterImages(images[-1], np_final,number_of_inters, 
                                    processed_inters)
    return images

#TESTED
def getErode(np_org_image, number_of_inters=2, struct_elem='cross', size=3): 
    """Execute erode morphological operation on image
    Function binaryzed image by OTSU method, so pass RGB or grayscale images possible.
    Keyword argument:
    filename --  filename or path to image
    struct_elem:
        cross - cross structural element
        rect - rectangle structural element
        circ -- cricle structural element(maybe implemente)
    size: size of struct element, should be 2N+1
    Return:
        Binarized image after erode operation
    """
    
    processed_inters = 0
    images = []
    #original image will be appended in Otsu binaryzation 

    bin_images= getOtsuBinaryzedImage(np_org_image,0)
    processed_inters += len(bin_images) - 1             #minus original image
    images += bin_images

    np_final = bn.erode(images[-1], struct_elem, size)

    images += bs.generateInterImages(images[-1], np_final,number_of_inters, 
                                    processed_inters)
    return images

#TESTED
def getOpenly(np_org_image, number_of_inters=3, struct_elem='rect', size=3): 
    """Execute openly(erode and dilate on the same image) morphological operation on image
    Function binaryzed image by OTSU method, so pass RGB or grayscale images possible.
    Keyword argument:
    filename --  filename or path to image
    struct_elem:
        cross - cross structural element
        rect - rectangle structural element
        circ -- cricle structural element(maybe implemente)
    size: size of struct element, should be 2N+1
    Return:
        Binarized image after openly operation
    """

    processed_inters = 0
    images = []
    #original image will be appended in Otsu binaryzation 

    #binaryzation part
    bin_images= getOtsuBinaryzedImage(np_org_image,0)
    processed_inters += len(bin_images) - 1             #minus original image
    images += bin_images

    #erode part
    np_image_er = bn.erode(images[-1], struct_elem, size)
    #calculate number of inters to erode operation
    erode_inters = math.floor((number_of_inters-processed_inters)/2 - 1)
    if erode_inters > 0:
        images += bs.generateInterImages(images[-1], np_image_er,
                                        processed_inters+erode_inters,
                                        processed_inters)
        processed_inters += erode_inters 
    else:
        images.append(np_image_er)

    #one from final erode image
    processed_inters += 1

    #dilate part
    np_final = bn.dilate(np_image_er, struct_elem, size)
    images += bs.generateInterImages(images[-1], np_final, number_of_inters,
                                     processed_inters)
    return images

#TESTED
def getClosely(np_org_image, number_of_inters=3, struct_elem='rect', size=3): 
    """Execute openly(erode and dilate on the same image) morphological operation on image
    Function binaryzed image by OTSU method, so pass RGB or grayscale images possible.
    Keyword argument:
    filename --  filename or path to image
    struct_elem:
        cross - cross structural element
        rect - rectangle structural element
        circ -- cricle structural element(maybe implemente)
    size: size of struct element, should be 2N+1
    Return:
        Binarized image after closely operation
    """
    processed_inters = 0
    images = []
    #original image will be appended in Otsu binaryzation 

    #binaryzation part
    bin_images= getOtsuBinaryzedImage(np_org_image,0)
    processed_inters += len(bin_images) - 1             #minus original image
    images += bin_images

    #dilate part
    np_image_dil = bn.dilate(images[-1], struct_elem, size)
    #calculate number of inters to erode operation
    dilate_inters = math.floor((number_of_inters-processed_inters)/2 - 1)
    if dilate_inters > 0:
        images += bs.generateInterImages(images[-1], np_image_dil,
                                        processed_inters+dilate_inters,
                                        processed_inters)
        processed_inters += dilate_inters 
    else:
        images.append(np_image_dil)

    #one from final erode image
    processed_inters += 1

    #erode part
    np_final = bn.erode(np_image_dil, struct_elem, size)
    images += bs.generateInterImages(images[-1], np_final, number_of_inters,
                                     processed_inters)
    return images

#TESTED
def filteringImage(np_org_image, np_mask, number_of_inters=1): 
    """
    Processing filtering with given kernel.
    If RGB image is passed, then each channel will be filter separately.
    Keyword argument:
    filename --  filename or path to image
    np_mask -- mask matrix as numpy array
    Return:
        np_image_fil -- image as numpy 2D array, after specified filtering
    """
    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.matrixFilter(np_org_image[:,:,0], np_mask) 
        np_final[:,:,1] = fil.matrixFilter(np_org_image[:,:,1], np_mask)
        np_final[:,:,2] = fil.matrixFilter(np_org_image[:,:,2], np_mask)
    else:
        np_final = fil.matrixFilter(np_org_image, np_mask)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images


def medianFiltergingImage(np_org_image, struct_elem='rect', size=3, number_of_inters=1):
    """
    Processing median filtering with specified shape and size on image given by filename
    If RGB image is passed, then each channel will be filter separately.
    Keyword argument:
    filename --  filename or path to image
    struct_elem:
        cross -- cross structural element
        rect -- rectangle structural element
        circ -- cricle structural element(maybe will be implemented)
    size: size of struct element, should be 2N+1
    Return:
        np_image_fil -- image as numpy 2D array, after median filtering
    
    """

    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.medianFilter(np_org_image[:,:,0], struct_elem, size) 
        np_final[:,:,1] = fil.medianFilter(np_org_image[:,:,1], struct_elem, size)
        np_final[:,:,2] = fil.medianFilter(np_org_image[:,:,2], struct_elem, size)
    else:
        np_final = fil.medianFilter(np_org_image, struct_elem, size)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

#TESTED
def gammaCorrection(np_org_image, gamma, number_of_inters=1): 
    """
    Processing gamma correction with specified gamma correction atribute
    If RGB image is passed, then each channel will be correct separately.
    Keyword argument:
    filename --  filename or path to image
    gamma - gamma correction parameter
    Return:
        np_image_gamma -- image as numpy 2D array, after gamma correction
    """
    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.gammaCorrection(np_org_image[:,:,0], gamma) 
        np_final[:,:,1] = fil.gammaCorrection(np_org_image[:,:,1], gamma)
        np_final[:,:,2] = fil.gammaCorrection(np_org_image[:,:,2], gamma)
    else:
        np_final = fil.gammaCorrection(np_org_image, gamma)


    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

#TESTED
def addGaussianNoise(np_org_image, std_dev=0.05, mean=0, number_of_inters=1): 
    """Adding gaussian noise with to given image
    Keyword argument:
    filename --  filename or path to image
    std_dev -- standard deviation parameter
    mean -- mean parameter (default = 0) 
    Return:
        Image with gaussian noise specified by parameters. Dimension the same as given.
    """

    images = []
    images.append(np_org_image) 
    np_image_3D, isConverted = bs.ensure3D(np_org_image)

    np_final = ns.gaussianNoise(np_image_3D, std_dev, mean)

    if isConverted:
        np_final = np_final.reshape(np_final.shape[:2])

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

  #TESTED  
def addSaltPepperNoise(np_org_image, propability = 0.05, saltPepperRatio = 0.5, number_of_inters=1): 
    """Adding salt pepper nois to given image
    Keyword argument:
    filename --  filename or path to image
    propability -- how much of image should be noising. Propability that single pixel become salt/pepper noise.
    (default = 0.5) 
    saltPepperRatio -- specified salt to pepper ratio (default 0.5):
        1.0 -- only salt
        0.5 -- equal propability of salt and pepper
        0.0 -- only pepper
    Return:
        Image noised with specified values. Dimension the same as given.
    """

    images = []
    images.append(np_org_image)   
    np_final =  ns.saltPepperNoising(np_org_image, propability, saltPepperRatio)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images


"""
#calling functions from python shell
if __name__ == "__main__":

    functions = {
        'getImageParameters': getImageParameters,
        'toGrayscale': toGrayscale,
        'getBinaryzedImage': getBinaryzedImage,
        'getOtsuBinaryzedImage': getOtsuBinaryzedImage,
        'getDilate': getDilate,
        'getErode': getErode,
        'getOpening': getOpening,
        'getClosing': getClosing,
        'filteringImage': filteringImage,
        'medianFiltergingImage': medianFiltergingImage,
        'gammaCorrection': gammaCorrection,
        'addGaussianNoise': addGaussianNoise,
        'addSaltPepperNoise': addSaltPepperNoise,
        'removeFiles': removeFiles
    }
    
    option = sys.argv[1]
    parameters = sys.argv[2:]

    for i in range(len(parameters)):
        try:
            parameters[i] = int(parameters[i])
        except ValueError:
            try:
                parameters[i] = float(parameters[i])
            except ValueError:
                continue

    if len(sys.argv) >=1:
        functions[option](*parameters)
"""

images = []
np_image = bs.readImage("Lena.png", verbose=False)
np_image_gray = toGrayscale(np_image)
images = medianFiltergingImage(np_image)
bs.show_images(images)

