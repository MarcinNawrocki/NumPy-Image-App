import json
import math

import numpy as np
import matplotlib.pyplot as plt
from skimage import filters

import basic_operations as bs 
import binary_operations as bn 
import noising as ns 
import filtering as fil 

#filters
#dolnoprzepustowe
np_LP1 = np.array([[1,1,1],[1,1,1], [1,1,1]])
np_LP2 = np.array([[1,1,1],[1,2,1], [1,1,1]])
np_LP3 = np.array([[1,1,1],[1,4,1], [1,1,1]])
np_LP4 = np.array([[1,1,1],[1,12,1], [1,1,1]])

#g√≥rnoprzepustowe
np_HP1 = np.array([[-1,-1,-1],[-1,9,-1], [-1,-1,-1]])
np_HP2 = np.array([[0,-1,0],[-1,5,-1], [0,-1,0]])
np_HP3 = np.array([[1,-2,1],[-2,5,-2], [1,-2,1]])
np_HP4 = np.array([[0,-1,0],[-1,20,-1], [0,-1,0]])

#add more from
#http://www.algorytm.org/przetwarzanie-obrazow/filtrowanie-obrazow.html

#TODO:
#- docstrings in other files

#New funcionalities
#- showing descriptions while showing images (propably function should return the object not only list of images)

def grayscale(np_org_image, gray="human"):
    """Converts image to grayscale 

    Arguments:
        np_org_image {NumPy array} -- image for convertion to grayscale

    Keyword Arguments:
        gray {str} -- Choose conversion type  (default: {"human"})
             human - converts using: (0,215*R+0.7151*G+0.0721*B)
             machine - converts using (R+G+B)/3
            
    Returns:
        [NumPy array] -- image converted to grayscale
    """
    
    if bs.isColorImage(np_org_image):
        if gray == "human":
            np_final = bs.getHumanGrayscale(np_org_image)

        elif gray == "machine":
            np_final = bs.getMachineGrayscale(np_org_image)
        else: #default -- np_org_image
            np_final = bs.getHumanGrayscale(np_org_image)
    else:
        np_final = np_org_image

    return np_final

def binarization(np_org_image, threshold, number_of_inters=1): 
    """Perform binarization on a given image using specified threshold value

    Arguments:
        np_org_image {NumPy array} -- image for binarization
        threshold {[type]} -- binarization threshold from range <0,255>

    Keyword Arguments:
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {2})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """

    #arguments validation 
    #bs.validate_number_of_inters(number_of_inters, binarization.__defaults__[-1])
    if threshold > 255 or threshold < 0:
        raise ValueError (f"Threshold value out of <0,255> range. The value was {threshold}")

    processed_inters = 0
    images = []
    images.append(np_org_image)

    #grayscale
    np_image_2D, isConverted = bs.ensureGrayscale(np_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    #binarization
    np_final = bn.thresholdBinarization(np_image_2D, threshold)
    #number_of_inters = 0 indicates that function was called by other api function
    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters, processed_inters)
    return images   

def otsu_binarization(np_org_image, number_of_inters=1):
    """Perform binarization on a given image using a threshold calculate by OTSU method

    Arguments:
        np_org_image {NumPy array} -- image for binarization

    Keyword Arguments:
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {2})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    #bs.validate_number_of_inters(number_of_inters, otsu_binarization.__defaults__[-1])
    #get threshold calculated by OTSU method
    otsu_threshold = bn.otsuBinarization(np_org_image)
    
    return binarization(np_org_image, otsu_threshold, number_of_inters)

def dilation(np_org_image, struct_elem='rect', size=3, number_of_inters=2): 
    """Execute dilation on a given image

    Arguments:
        np_org_image {NumPy array} -- image for dilation

    Keyword Arguments:
        struct_elem {str} -- stuctural element used during dilation (default: {'rect'})
            rect - rectange
            cross - cross   
        size {int} -- size of the structural element. Should be odd and greater than 2 (default: {3})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {2})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """

    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, dilation.__defaults__[-1])
    
    #variable initialization
    processed_inters = 0
    images = []
    images.append(np_org_image)

    #grayscale
    np_image_2D, isConverted = bs.ensureGrayscale(np_org_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    #binarization
    np_image_bin= bn.otsuBinarization(images[-1], only_threshold = False)
    processed_inters += 1        
    images.append(np_image_bin)

    #dilation
    np_final = bn.dilate(images[-1], struct_elem, size)
    images += bs.generateInterImages(images[-1], np_final,number_of_inters, 
                                    processed_inters)
    return images

def erosion(np_org_image, struct_elem='rect', size=3, number_of_inters=2): 
    """Execute erosion on a given image

    Arguments:
        np_org_image {NumPy array} -- image for erosion 

    Keyword Arguments:
        struct_elem {str} -- stuctural element used during erosion (default: {'rect'})
            rect - rectange
            cross - cross
        size {int} -- size of the structural element. Should be odd and greater than 2 (default: {3})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {2})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, erosion.__defaults__[-1])

    processed_inters = 0
    images = []
    images.append(np_org_image)

    #grayscale
    np_image_2D, isConverted = bs.ensureGrayscale(np_org_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    #binarization
    np_image_bin= bn.otsuBinarization(images[-1], only_threshold = False)
    processed_inters += 1        
    images.append(np_image_bin)

    #erosion
    np_final = bn.erode(images[-1], struct_elem, size)

    images += bs.generateInterImages(images[-1], np_final,number_of_inters, 
                                    processed_inters)
    return images

def openly(np_org_image, struct_elem='rect', size=3, number_of_inters=3): 
    """Execute openly (dilation on eroded image) on a given image 

    Arguments:
        np_org_image {NumPy array} -- image for openly

    Keyword Arguments:
        struct_elem {str} -- stuctural element used during openly (default: {'rect'})
            rect - rectange
            cross - cross   
        size {int} -- size of the structural element. Should be odd and greater than 2 (default: {3})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {3})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, openly.__defaults__[-1])

    processed_inters = 0
    images = []
    images.append(np_org_image) 

    #grayscale
    np_image_2D, isConverted = bs.ensureGrayscale(np_org_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    #binarization
    np_image_bin= bn.otsuBinarization(images[-1], only_threshold = False)
    processed_inters += 1        
    images.append(np_image_bin)

    #erode part
    np_image_er = bn.erode(images[-1], struct_elem, size)
    #calculate number of inters to erode operation
    erode_inters = math.floor((number_of_inters-processed_inters)/2 - 1)
    if erode_inters > 0:
        images += bs.generateInterImages(images[-1], np_image_er,
                                        processed_inters+erode_inters,
                                        processed_inters)
        processed_inters += erode_inters 
    else:
        images.append(np_image_er)

    #one from final erode image
    processed_inters += 1

    #dilate part
    np_final = bn.dilate(np_image_er, struct_elem, size)
    images += bs.generateInterImages(images[-1], np_final, number_of_inters,
                                     processed_inters)
    return images

def closely(np_org_image, number_of_inters=3, struct_elem='rect', size=3): 
    """Execute closely (erosion on dilated image) on a given image 

    Arguments:
        np_org_image {NumPy array} -- image for erosion

    Keyword Arguments:
        struct_elem {str} -- stuctural element used during erosion  (default: {'rect'})
            rect - rectange
            cross - cross
        size {int} -- size of the structural element. Should be odd and greater than 2 (default: {3})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {3})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """

    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, closely.__defaults__[-1])

    processed_inters = 0
    images = []
    images.append(np_org_image)

    #grayscale
    np_image_2D, isConverted = bs.ensureGrayscale(np_org_image, info = True)
    if isConverted:
        images.append(np_image_2D)
        processed_inters += 1

    #binarization
    np_image_bin= bn.otsuBinarization(images[-1], only_threshold = False)
    processed_inters += 1        
    images.append(np_image_bin)

    #dilate part
    np_image_dil = bn.dilate(images[-1], struct_elem, size)
    #calculate number of inters to erode operation
    dilate_inters = math.floor((number_of_inters-processed_inters)/2 - 1)
    if dilate_inters > 0:
        images += bs.generateInterImages(images[-1], np_image_dil,
                                        processed_inters+dilate_inters,
                                        processed_inters)
        processed_inters += dilate_inters 
    else:
        images.append(np_image_dil)

    #one from final dilate image
    processed_inters += 1

    #erode part
    np_final = bn.erode(np_image_dil, struct_elem, size)
    images += bs.generateInterImages(images[-1], np_final, number_of_inters,
                                     processed_inters)
    return images

def filtering(np_org_image, np_mask, number_of_inters=1): 
    """Filtering on a given image using specified mask.

    Arguments:
        np_org_image {NumPy array} -- image for filtering
        np_mask {[NumPy array]} -- filter mask. You could pass your own or use one from the predefinied:
            np_LP1-4 - low pass filter masks, where 1 means filter with the "strongest" low pass effect (size: {3x3})
            np_HP1-4 - high pass filter masks, where 1 means filter with the "strongest" high pass effect (size: {3x3})

    Keyword Arguments:
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {1})

    Returns:
         [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, filtering.__defaults__[-1])

    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.matrixFilter(np_org_image[:,:,0], np_mask) 
        np_final[:,:,1] = fil.matrixFilter(np_org_image[:,:,1], np_mask)
        np_final[:,:,2] = fil.matrixFilter(np_org_image[:,:,2], np_mask)
    else:
        np_final = fil.matrixFilter(np_org_image, np_mask)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

def median_filtering(np_org_image, struct_elem='rect', size=3, number_of_inters=1):
    """Median filtering on a given image .

    Arguments:
        np_org_image {NumPy array} -- image for median filtering

    Keyword Arguments:
        struct_elem {str} -- stuctural element from which median value will be calculated  (default: {'rect'})
            rect - rectange
            cross - cross
        size {int} -- size of the structural element. Should be odd and greater than 2 (default: {3})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {1})

    Returns:
         [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, median_filtering.__defaults__[-1])

    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.medianFilter(np_org_image[:,:,0], struct_elem, size) 
        np_final[:,:,1] = fil.medianFilter(np_org_image[:,:,1], struct_elem, size)
        np_final[:,:,2] = fil.medianFilter(np_org_image[:,:,2], struct_elem, size)
    else:
        np_final = fil.medianFilter(np_org_image, struct_elem, size)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

def gamma_correction(np_org_image, gamma, number_of_inters=1): 
    """Gamma correction on given image using specified gamma coefficient

    Arguments:
        np_org_image {NumPy array} -- image for median filtering
        gamma {[float]} -- gamma coefficient. Should be greater than 0

    Keyword Arguments:
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {1})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """

    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, gamma_correction.__defaults__[-1])

    images = []
    images.append(np_org_image)
    np_final = np.empty(np_org_image.shape, dtype = np.uint8)

    if bs.isColorImage(np_org_image):
        np_final[:,:,0] = fil.gammaCorrection(np_org_image[:,:,0], gamma) 
        np_final[:,:,1] = fil.gammaCorrection(np_org_image[:,:,1], gamma)
        np_final[:,:,2] = fil.gammaCorrection(np_org_image[:,:,2], gamma)
    else:
        np_final = fil.gammaCorrection(np_org_image, gamma)


    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

def gaussian_noising(np_org_image, std_dev=0.05, mean=0, number_of_inters=1): 
    """Applying gaussian noise on a given image with specified standar deviation and mean parameters

    Arguments:
        np_org_image {NumPy array} -- image for median filtering

    Keyword Arguments:
        std_dev {float} -- standard deviation of gaussian noise (default: {0.05})
        mean {int} --mean of gaussian noise (default: {0})
        number_of_inters {int} -- number of inter images generated by this function (minimum/default: {1})

    Returns:
         [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, gaussian_noising.__defaults__[-1])

    images = []
    images.append(np_org_image) 
    np_image_3D, isConverted = bs.ensure3D(np_org_image)

    np_final = ns.gaussianNoise(np_image_3D, std_dev, mean)

    if isConverted:
        np_final = np_final.reshape(np_final.shape[:2])

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images
  
def salt_pepper_noising(np_org_image, propability = 0.05, saltPepperRatio = 0.5, number_of_inters=1): 
    """Applying salt(white pixel)/pepper(black pixel) noise on a given image
    Arguments:
        np_org_image {NumPy array} -- image for median filtering

    Keyword Arguments:
        propability {float} -- propability of noising a single pixel (default: {0.05})
        saltPepperRatio {float} -- specified salt to pepper ratio (default: {0.5})
                1.0 -- only salt
                0.5 -- equal propability of salt and pepper
                0.0 -- only pepper

         number_of_inters {int} -- number of inter images generated by this function (minimum/default: {1})

    Returns:
        [list of NumPy arrays] -- list containing original image, specified number of inter images and final image
    """
    #arguments validation 
    bs.validate_number_of_inters(number_of_inters, salt_pepper_noising.__defaults__[-1])

    images = []
    images.append(np_org_image)   
    np_final =  ns.saltPepperNoising(np_org_image, propability, saltPepperRatio)

    images += bs.generateInterImages(images[-1], np_final,
                                    number_of_inters)
    return images

def show_images(images, color_map='gray'):
    """Displaying images list or single image generated by another functions.

    Arguments:
        images {list/NumPy arrays} -- bunch of a images as list of NumPy arrays or single image as NumPy array

    Keyword Arguments:
        color_map {str} -- cmap argument for matplotlib.pyplot.imshow function (default: {'gray'})
    """
    if (type(images) is list):
        number_of_images = len(images)
        nrows = number_of_images // 5
        ncols = number_of_images // nrows
        fig, ax = plt.subplots(nrows=nrows, ncols=ncols, figsize=(8,8))
        for i, axi in enumerate(ax.flat):
            axi.imshow(images[i], cmap = color_map)
        plt.tight_layout(True)
        plt.show()
    else:
        try:
            plt.imshow(images, cmap = color_map)
            plt.show()
        except TypeError as e:
            print("Non displayable data passed. Should be a list of NumPy arrays or a numpy array.")
            print("Matplotlib error info: ", e)